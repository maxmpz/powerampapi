<?xml version="1.0" encoding="utf-8"?>
<!--
Copyright (C) 2010-2022 Maksim Petrov

Redistribution and use in source and binary forms, with or without
modification, are permitted for themes, skins, widgets, plugins, applications and other software
which communicate with Poweramp music player application on Android platform.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<resources xmlns:tools="http://schemas.android.com/tools">
	<item type="id" name="bus_player"/><!-- PlayerService msg bus. Also a state bus. Separated from PlayerService, exists even when no PS loaded yet -->
	<item type="id" name="bus_player_cmd"/><!-- PlayerService cmd bus (for cmd_*). Public -->
	
	<item type="id" name="bus_dsp"/><!-- Also a state bus -->
	<item type="id" name="bus_dsp_cmd"/>

	<item type="id" name="bus_data_cmd"/>


	<!-- StateBus: bus_gui -->
	<item type="id" name="state_nav"/><!-- integer, one of bus_nav* -->
	<item type="id" name="state_prev_nav"/><!-- integer, one of bus_nav* -->
	<item type="id" name="state_reqested_next_nav"/><!-- integer, one of bus_nav* -->
	
	<item type="id" name="cmd_app_disable_scan"/><!-- arg1 == 1 disable, 0 == enable. Disable state is counted -->
	<!-- bus_app_cmd. arg1 == 1 don't refresh aa, otherwise clear in-memory AA caches and send msg_app_aa_refreshed -->
	<item type="id" name="cmd_app_refresh_aa"/>
	<item type="id" name="cmd_app_clean_aa"/><!-- arg1 => aa type, arg2 => boolean - send msg_app_aa_refreshed if cleared something, obj => LongArray with ids to clean cache for -->
	<item type="id" name="cmd_app_close_settings"/><!-- Closes all open setting activities -->
	<item type="id" name="cmd_app_open"/><!-- arg2 => intent flags, obj => String uri -->
	<item type="id" name="cmd_app_open_support"/>
	<item type="id" name="cmd_app_rescan"/><!-- arg1 => boolean, slow scan if true, obj => String cause of rescan -->
	<item type="id" name="cmd_app_milk_rescan"/><!-- arg1 => boolean, slow scan if true, arg2 => boolean, force resolve playlists, obj => String cause of rescan -->
	<item type="id" name="cmd_app_storage_perm_dialog"/><!-- obj => PermissionRequest. NOTE: dialogs can intercept result if dialog activity sets itself as registerLastStartedNonDialogActivity() in onStart, arg1 => true to avoid success toast -->
	<item type="id" name="cmd_app_close_activities"/><!-- Not closing settings activities - see cmd_app_close_settings -->
	<item type="id" name="msg_app_storage_perm_granted"/>
	<item type="id" name="msg_app_storage_perm_failed"/>
	
	<item type="id" name="cmd_app_create_file_dialog"/><!-- obj => CreateFileRequest -->
	<item type="id" name="msg_app_create_file_dialog_res"/><!-- obj => uri or null -->
	<item type="id" name="cmd_app_open_file_dialog"/><!-- obj => OpenFileRequest -->
	<item type="id" name="msg_app_open_file_dialog_res"/><!-- obj => uri or null -->
	
	<item type="id" name="msg_app_aa_refreshed"/><!-- bus_app. Refretch AA. Should be sent by AppAAProvider after cmd_app_refresh_aa  -->
	<!-- bus_app. Current track AA is probably reloaded w/o track change (e.g. for the streams), no cache reset.
	     This will make effect if GUI compoments actually reloaded AA, e.g. due to the msg_app_data_changed -->
	<item type="id" name="msg_app_track_aa_refreshed"/><!-- REVISIT: use msg_app_aa_refreshed? -->

	<item type="id" name="msg_app_dir_scan_started"/>
	<item type="id" name="msg_app_dir_scan_finished"/>
	<item type="id" name="msg_app_dir_scan_progress"/><!-- arg1 => dirCount, arg2 => fileCount -->
	<item type="id" name="msg_app_tag_scan_started"/>
	<item type="id" name="msg_app_tag_scan_progress"/><!-- arg1 => fileCount -->
	<item type="id" name="msg_app_tag_scan_finished"/><!-- arg1=boolean tracksChanged, arg2=int flags -->
	<item type="id" name="msg_app_data_changed"/><!-- bus_app. obj => RestEntity of data changed, or "settings"/null for global refresh, arg1 => RestLibrary.DATA_CHANGED_* -->
	<item type="id" name="msg_app_milk_data_changed"/><!-- obj => RestMilkPreset. MilkRNP reloads, includes any milk data changes, sort, etc. Needed to avoid reacting to msg_player_milk_preset_changed on each preset change -->
	<item type="id" name="msg_app_settings_index_changed"/>
	<item type="id" name="msg_app_data_added"/>
	<item type="id" name="cmd_app_on_mediabrowser_started"/><!-- NOTE: needed to track browser state, obj = broswer client pak. Sent for browser onCreate with __unknown__ and for every getRoot with client package -->
	<item type="id" name="cmd_app_on_mediabrowser_stopped"/><!-- obj = broswer client pak -->
	<item type="id" name="msg_app_mediabrowser_started"/>
	<item type="id" name="msg_app_mediabrowser_stopped"/>
	<item type="id" name="msg_app_mediabrowser_refresh"/><!-- Force BrowserSerivce to send refresh event, e.g. when some browser specific options are changed -->
	<item type="id" name="msg_app_version_check"/><!-- arg1 => boolean started/ended, arg2 => response version code -->
		
	<item type="id" name="state_app_scanning"/><!-- boolean, true if there is a folders/library scan running, int - state of the scanning -->

	<item type="id" name="cmd_app_on_lockscreen_mode"/><!-- arg1 => 1 - ls active, 0 - ls not active -->
	<item type="id" name="state_app_lockscreen_active"/><!-- boolean --> 
	<item type="id" name="state_app_browser_started"/><!-- boolean or String == browser last connected package -->
	<item type="id" name="state_app_shutdown"/><!-- boolean, true => device shutdown is in effect -->
	<item type="id" name="state_app_edition_name"/><!-- String -->
	<item type="id" name="state_app_edition_icon"/><!-- int -->
			
	<!-- <item type="id" name="cmd_disable_nav"/> NOTE: not used ATM --><!-- bus_gui -->
	<!-- <item type="id" name="cmd_enable_nav"/>  NOTE: not used ATM --><!-- bus_gui -->
	
	<!-- NOTE: nav commands are sent for TopNav helper, it's not necessary that such command will be actually executed, as navigation
	     can be disabled or other state disallows navigation change.
	     Thus, listen to nav_* msgs for confirmed navigation change -->
	     
	<item type="id" name="cmd_nav_to_lib"/><!-- bus_gui -->
	<item type="id" name="cmd_nav_to_main"/><!-- bus_gui -->
	<item type="id" name="cmd_nav_to_search"/><!-- bus_gui -->
	<item type="id" name="cmd_nav_more"/><!-- bus_gui -->
	<item type="id" name="cmd_nav_to_eq"/><!-- bus_gui, arg1 => EQ_TAB_* -->
	<item type="id" name="cmd_nav_to_lyrics"/><!-- bus_gui. Navigates to the current track lyrics -->
	<item type="id" name="cmd_nav_to_lyrics_or_app"/><!-- bus_gui -->
	<item type="id" name="cmd_open_lyrics_app"/><!-- bus_gui -->

	
	<item type="id" name="nav_lib"/><!-- bus_gui, arg1 = LIB_* -->
	<item type="id" name="nav_main"/><!-- bus_gui -->
	<item type="id" name="nav_search"/><!-- bus_gui, arg1 => boolean focusSearchText -->
	<item type="id" name="nav_eq"/><!-- bus_gui, arg1 => EQ_TAB_*  -->
	<item type="id" name="nav_lyrics"/><!-- bus_gui -->

	<!-- Opens last used tab -->
	<integer name="EQ_TAB_DEFAULT">-1</integer><!-- Sync with TopNavHelper -->
	<integer name="EQ_TAB_EQ">0</integer>
	<integer name="EQ_TAB_VOL">1</integer>
	<integer name="EQ_TAB_REVERB">2</integer>
	
	<item type="id" name="cmd_gui_show_toast_for_shuffle_mode"/><!-- obj => optional toast CharSequence for line2 -->
	<item type="id" name="cmd_gui_open_help"/>	 
	<item type="id" name="cmd_gui_close_help"/>
	
	<item type="id" name="cmd_gui_set_vis_mode"/><!-- bus_gui, integer VIS_* -->
	<item type="id" name="cmd_gui_apply_aa_blur_prefs"/><!-- bus_gui -->
	<item type="id" name="cmd_gui_show_hide_milk"/><!-- bus_gui, arg1 => STATE_TRUE => show, STATE_FALSE => hide -->

	<!--<item type="id" name="cmd_gui_set_lyrics_state"/>&lt;!&ndash; bus_gui, arg1 = LyricsState.LYRICS_STATE_* &ndash;&gt;-->
	<!--<item type="id" name="cmd_gui_toggle_lyrics"/>&lt;!&ndash; bus_gui &ndash;&gt;-->

	
	<item type="id" name="cmd_data_info_tags"/><!-- bus_data_cmd, obj => IdAndPath,Long fileId, String/Uri => file path/uri, null => current track -->
	<item type="id" name="cmd_data_edit_tags"/><!-- bus_data_cmd, obj => IdAndPath,Long fileId, String/Uri => file path/uri, null => current track -->
	<item type="id" name="cmd_data_lyrics"/><!-- bus_data_cmd -->
	
	<item type="id" name="cmd_list_select_aa_dialog"/><!-- NOTE: calls cmd_data_album_art -->
	<item type="id" name="cmd_data_album_art"/><!-- bus_data_cmd, arg1: 0 (default, show for current PS loaded track)/RestLibrary.AA_TYPE_*; obj => IdAndPath, Long fileId, String/Uri => file path/uri, null => current track  -->
	<item type="id" name="cmd_data_track_rating"/><!-- bus_data_cmd, arg1 => rating, obj => Long fileId -->
	<item type="id" name="cmd_data_reset_aa_status"/>
	<item type="id" name="msg_app_data_rating_changed"/><!-- arg1 => rating, arg2 => previous rating, obj => Long fileId -->

	
	<item type="id" name="cmd_data_delete"/><!-- bus_data_cmd, obj => UriAndIds -->
	<item type="id" name="cmd_data_reorder"/><!-- bus_data_cmd, obj => UriAndIds -->
	<item type="id" name="cmd_data_save_playlist"/><!-- obj => uri -->
	
	<item type="id" name="cmd_list_delete_dialog"/>
	<item type="id" name="cmd_data_mass_delete"/><!-- bus_data_cmd, obj => UriAndIds, arg1 => true/1 - don't change track -->
	
	<item type="id" name="cmd_list_send_dialog"/>
	<item type="id" name="cmd_data_mass_send"/><!-- bus-data_cmd, obj =>UriAndIds -->
	
	<item type="id" name="cmd_list_rename_dialog"/>
	<item type="id" name="cmd_list_export"/>
	<item type="id" name="cmd_data_export"/><!-- bus-data_cmd, obj =>UriAndIds -->
	<item type="id" name="cmd_list_import"/>
	<item type="id" name="cmd_data_import"/><!-- bus-data_cmd, obj =>UriAndIds -->
	<item type="id" name="cmd_list_share"/>
	<item type="id" name="cmd_data_share"/><!-- bus-data_cmd, obj =>UriAndIds -->
	
	<item type="id" name="cmd_data_update"/><!-- bus_data_cmd, obj => UriAndIds, arg1 => true/1 - don't send msg_app_data_changed -->
	<item type="id" name="cmd_data_rename"/><!-- bus_data_cmd, obj => UriAndIds. Like cmd_data_update, but also handles RestLibraryEntityRenameSupport -->
	<item type="id" name="cmd_data_update_or_add"/><!-- bus_data_cmd, obj => UriAndIds[2], arg1 => true/1 - don't send msg_app_data_changed -->
	
	<item type="id" name="cmd_list_preset_assign_dialog"/>
	<item type="id" name="cmd_data_eq_preset_assign"/><!-- bus_data_cmd, obj => UriAndIds -->
	
	<item type="id" name="cmd_list_delete_dups_dialog"/>
	<item type="id" name="cmd_data_delete_dups"/><!-- obj => Long playlist id -->

	<item type="id" name="cmd_list_resort_dialog"/>
	<item type="id" name="cmd_data_resort"/><!-- arg1 => int PlaylistSortHelper.SORT_*, obj => uri (playlist/#/files / queue) -->
	
	<item type="id" name="cmd_list_add_to_pl_dialog"/>
	<item type="id" name="cmd_data_mass_add_to_pl"/><!-- arg1 => int playlist insert pos, obj => UriAndIds -->
	
	<item type="id" name="cmd_list_clear_q"/><!-- Same as cmd_data_clear_q, reposted to bus_data_cmd -->
	<item type="id" name="cmd_data_clear_q"/>
	
	<item type="id" name="cmd_list_clear_list"/><!-- Same as cmd_data_clear_list, reposted to bus_data_cmd with current list entity -->
	<item type="id" name="cmd_data_clear_list"/>
	
	<item type="id" name="cmd_list_show_all"/>
	<item type="id" name="cmd_data_show_all"/>

	<item type="id" name="cmd_list_update_zoom"/><!-- arg1 => boolean force, arg2 => zoomType -->
	
	<item type="id" name="cmd_list_current_artist"/><!-- May have obj => Long - the artist id -->
	<item type="id" name="cmd_list_current_album"/>
	<item type="id" name="cmd_list_current_folder"/><!-- If folders_hier is active, goes to folders hierarchy, just to folders otherwise -->
	<item type="id" name="cmd_list_current_genre"/><!-- Requires obj => Long - the genre id -->
	<item type="id" name="cmd_request_current_genre"/><!-- bus_data_cmd. Calls => cmd_list_current_genre with appropriate current track first picked genre id -->
	<item type="id" name="cmd_request_current_artist"/><!-- bus_data_cmd. Calls => cmd_list_current_artist with the appropriate artists, probably taken from db for multi-artists -->
	
	<item type="id" name="cmd_data_bookmark_now"/>
	<item type="id" name="cmd_list_rescan"/>
	<item type="id" name="cmd_data_request_rescan"/><!-- Resolves obj => uri to extra info as needed for the rescan and starts it -->

	<!-- arg1 => int insertPos, obj => UriAndIds -->
	<item type="id" name="cmd_data_mass_add_to_q"/>
	
	
	
	<item type="id" name="cmd_data_add_eq_preset_dialog"/><!-- bus_data_cmd -->
	<item type="id" name="cmd_data_add_reverb_preset_dialog"/><!-- bus_data_cmd -->
	
	<item type="id" name="cmd_data_add_eq_preset"/><!-- bus_data_cmd, obj => UriAndIds -->
	<item type="id" name="cmd_data_add"/><!-- bus_data_cmd, obj => UriAndIds -->
	
	<item type="id" name="cmd_data_search_and_play"/><!-- bus_data_cmd, obj => search String -->
	<item type="id" name="cmd_data_play_intent"/><!-- bus_data_cmd, obj => Intent. arg1 => allow flags. Handles various types of ACTION_VIEW intents, such as uri playback, playlist import, preset import --> 
	<item type="id" name="cmd_data_nav_to_lib_pos"/><!-- arg1 => pos hint, arg2 => extra TopNavHelper flags, obj => uri -->
	<item type="id" name="cmd_data_nav_to_name"/><!-- obj => Uri + PARAM_NAME -->
	
	<item type="id" name="cmd_data_set_list_meta"/><!-- obj => UriAndIds -->
	<item type="id" name="cmd_data_index_settings"/>
	
	<item type="id" name="cmd_list_options_dialog"/>
	<item type="id" name="cmd_list_empty_dialog"/><!-- Dialog shown when gears button clicked in empty list => depends on list current Page -->
	<item type="id" name="cmd_list_force_ab_on_screen"/><!-- arg1 => ListWidgetBase.LOCK_AB_* -->
	
	<item type="id" name="cmd_list_target_search"/>
	<item type="id" name="cmd_list_clear_target_search"/>
	<item type="id" name="msg_list_cleared_target_search"/><!-- bus == list -->
	<item type="id" name="state_list_targeted_search"/><!-- boolean, true for targeted search mode, string, non-null targeted search label, or null if non-target/search mode -->

	<item type="id" name="cmd_data_add_playlist"/><!-- obj => default title -->
	<item type="id" name="cmd_data_update_track_info"/>
	
	<item type="id" name="cmd_data_update_eq_preset"/>

	<item type="id" name="cmd_data_update_search_history"/><!-- obj => search term -->
	<item type="id" name="cmd_data_clear_search_history"/><!-- obj => search term to clear term, arg1 => STATE_TRUE to clear whole history -->
	<item type="id" name="cmd_data_update_lyrics"/><!-- obj -> intent or bundle which follows ACTION_UPDATE_LYRICS API -->
	
	<item type="id" name="cmd_list_add_to_q"/>
	<item type="id" name="cmd_list_add_as_next_to_q"/>
	<item type="id" name="cmd_list_info_dialog"/>
	<item type="id" name="cmd_list_album_art"/>
	<item type="id" name="cmd_list_play"/>
	<item type="id" name="cmd_list_shuffle"/><!-- Header reshuffle -->
	<item type="id" name="cmd_list_add_url"/><!-- Opens dialog -->
	<item type="id" name="cmd_list_bookmark"/>

	<item type="id" name="cmd_list_prefer_aa_state"/><!-- arg1 == list_aa_* -->

	<!-- Implemented by some popup lists, e.g. eq presets -->
	<item type="id" name="cmd_list_reload"/>

	<!-- Implemented by some popup lists, e.g. eq presets -->
	<item type="id" name="cmd_list_lock_unlock"/>

	<item type="id" name="state_gui_vis_mode"/><!-- integer VIS_* -->
	<item type="id" name="state_gui_eq_tab"/><!-- integer EQ_TAB_* -->
	<item type="id" name="state_gui_nav_allowed"/><!-- boolean -->
	
	<item type="id" name="state_gui_anim_durations"/><!-- obj -->
	
	<item type="id" name="msg_gui_vis_mode_changed"/><!-- integer VIS_* -->



	<item type="id" name="msg_app_screen_on"/><!-- arg1 => boolean => screen_on --> 
	<item type="id" name="state_app_screen_on"/><!-- boolean -->

	<!-- System shutdown or app shutdown due to the forced exit. Also can be sent to bus_app_cmd to initiate the shutdown event.
	     obj => String? - cause of the shutdown -->
	<item type="id" name="msg_app_device_shutdown"/>
	<item type="id" name="msg_app_act_config_incremented"/>
	

	<!-- StateAnim states -->
	<!-- <item type="id" name="anim_playing" /> -->
	<item type="id" name="anim_seeking" />
	<item type="id" name="anim_state_lyrics"/>
	<item type="id" name="anim_state_lyrics_max"/>
	
	<item type="id" name="anim_knob_pressed"/>
					
	<!-- bus_player -->
	<!-- bus_player PS outbound messages -->
	<integer name="TRACK_CHANGED_SAME_UPDATED">0x1</integer><!-- Sync with Track.java -->

	<item type="id" name="msg_player_service_connected"/>
	<item type="id" name="msg_player_service_disconnected"/>
	<item type="id" name="msg_player_service_started"/><!-- Also called when mediasession is recreated -->
	<item type="id" name="msg_player_service_stopped"/>
	<item type="id" name="msg_pipeline_started"/><!-- Internal usage: obj parameter => PipelineSession -->
	<item type="id" name="msg_pipeline_stopped"/><!-- Internal usage -->
	<item type="id" name="msg_player_milk_audio_source_fd"/>
	<item type="id" name="msg_player_milk_preset_changed"/><!-- obj => MilkPreset -->
	
	<item type="id" name="msg_player_track_changed"/><!-- arg1 => TRACK_CHANGED_*, obj => Track -->
	<item type="id" name="msg_player_playing_state_changed"/><!-- arg1 => state. Hard-pause/soft-resume -->
	<item type="id" name="msg_player_playing_state_changed_alt"/><!-- Soft-pause/hard-resume -->
	<item type="id" name="msg_player_track_seek"/><!-- arg1 => posMs -->
	<item type="id" name="msg_player_repeat_mode_changed"/><!-- arg1 => @integer/REPEAT_*, arg2 = boolean - show toast, obj = MetaTrackInfo (if it's changed) -->
	<item type="id" name="msg_player_shuffle_mode_changed"/><!-- arg1 => @integer/SHUFFLE_*, arg2 = boolean - show toast -->
	<item type="id" name="msg_player_sleep_timer"/><!-- arg1 => seconds to sleep in, or 0 if sleep timer is disabled, arg2 => boolean playToEnd, obj => long future planned sleep time or null to reset it -->
	<item type="id" name="msg_player_track_meta_switched"/>
	<item type="id" name="msg_player_track_wave_changed"/>
	<!-- NOTE: this is called after cmd_player_on_queue_updated, but on bus_player, and only if PS is alive --> 
	<item type="id" name="msg_player_queue_changed"/><!-- arg1 = unplayed count, arg2 = total count, obj = Boolean.TRUE if enqueued-->
	<item type="id" name="msg_player_output_meta_changed"/><!-- arg1 => routed device_id, obj => OutputEndDeviceMetaInfo|null -->
	<item type="id" name="msg_player_output_info_changed"/><!-- arg1 => routed device_id, obj => ResolvedOutputInfo|null -->
	<item type="id" name="cmd_player_on_tempo_changed"/><!-- Internal -->
	<item type="id" name="msg_player_entity_reshuffled"/><!-- Internal, obj = entity -->
	<item type="id" name="msg_player_np_ended"/>
	
	<!-- PlayerState states -->
	<item type="id" name="state_player_service_connected"/><!-- boolean -->
	<item type="id" name="state_player_service_started"/><!-- boolean -->
	<item type="id" name="state_player_pipeline_started"/><!-- boolean -->

	<item type="id" name="state_player_track"/><!-- Track obj -->
	<item type="id" name="state_player_track_duration_ms"/><!-- int -->
	
	<!-- string. Switchable meta string: can be e.g. state_player_track_decode_info, output info, folder, next track info -->
	<item type="id" name="state_player_track_meta"/><!-- NOTE: updated on msgs: msg_player_track_changed, msg_pipeline_started, msg_player_track_meta_switched -->
	<!-- int => drawable res id, matches current state_player_track_meta and can be 0 --> 
	<item type="id" name="state_player_track_meta_icon"/>
	
	<!-- string. Short meta string: counter -->
	<item type="id" name="state_player_track_short_meta"/>
	
	<item type="id" name="state_player_queue_counter"/><!-- string -->
	<item type="id" name="state_player_playing_state"/><!-- int. Changed with msg_player_playing_state_changed/msg_player_playing_state_changed_alt -->
	<item type="id" name="state_player_shuffle_mode"/><!-- int. Changed with msg_player_shuffle_mode_changed/msg_player_track_changed -->
	<item type="id" name="state_player_repeat_mode"/><!-- int. Changed with msg_player_shuffle_mode_changed/msg_player_track_changed -->
	<item type="id" name="state_player_current_playing_pos_ms"/><!-- int. Reads native pipeline PTS position from shared mem -->
	<item type="id" name="state_player_np_serial"/><!-- int. Changed with msg_player_track_changed  -->
	<item type="id" name="state_player_category_navigable"/><!-- boolean. Changed with msg_player_track_changed -->
	<item type="id" name="state_player_category_not_navigable"/><!-- boolean. Changed with msg_player_track_changed -->
	
	<item type="id" name="state_player_latency"/><!-- int -->
	<item type="id" name="state_player_dsp_frames"/><!-- int -->
	<item type="id" name="state_player_dsp_bufs"/><!-- int -->
	
	<item type="id" name="state_player_output_caps"/><!-- int -->
	<item type="id" name="state_player_output_plugin_id"/><!-- int -->
	<item type="id" name="state_player_output_plugin_name"/><!-- string -->
	<item type="id" name="state_player_output_plugin_uniq_name"/><!-- string -->
	<item type="id" name="state_player_output_variant"/><!-- string -->

	<item type="id" name="state_player_sample_rate"/><!-- int. The pipeline and output plugin sample rate -->

	<item type="id" name="state_player_output_buf_format"/><!-- int. the format we ask output to use -->
	<item type="id" name="state_player_output_buf_bits"/><!-- int. The format bits we ask output to use -->

	<item type="id" name="state_player_output_resolved_sample_rate"/><!-- int. If resolved: AF output sample rate, -1 otherwise-->
	<item type="id" name="state_player_output_resolved_format"/><!-- int. If resolved: AF output format, -1 otherwise -->

	<item type="id" name="state_player_output_sample_rate"/><!-- int. If resolved: AF output sample rate, state_player_sample_rate otherwise -->
	<item type="id" name="state_player_output_format"/><!-- int. If resolved: AF output format, state_player_output_buf_format otherwise -->
	<item type="id" name="state_player_output_bits"/><!-- int. If resolved: AF output bits -> the actual played bits, state_player_output_buf_bits otherwise -->


	<item type="id" name="state_player_output_latency"/><!-- int -->
	<item type="id" name="state_player_output_device"/><!-- string, int -->
	<item type="id" name="state_player_output_device_flags"/><!-- int. Not used ATM -->
	<item type="id" name="state_player_output_end_device"/><!-- string, or boolean - true if we have end device name -->
	<!--<item type="id" name="state_player_output_end_device_address"/>--><!-- string -->
	<!-- string, obj => OutputEndDeviceMetaInfo -->
	<item type="id" name="state_player_output_end_device_meta"/>
	<item type="id" name="state_player_track_decode_info"/><!-- string -->
	<item type="id" name="state_player_output_info"/><!-- string -->
	<item type="id" name="state_player_output_meta"/><!-- string -->
	<item type="id" name="state_player_category_info"/><!-- string -->

	<item type="id" name="state_player_folder_info"/><!-- string -->
	<item type="id" name="state_player_next_track_info"/><!-- string -->
	<!-- int => seconds to sleep in, or 0 if sleep timer is disabled. 
		 boolean => enabled/disabled.
		 long => future sleep time in SystemClock.uptimeMillis base or 0 if no future time is set yet 
		         (sleep timer may be enabled, but pending) -->
	<item type="id" name="state_player_sleep_timer"/>
	<item type="id" name="state_player_sleep_timer_play_to_end"/>
	
	<item type="id" name="state_player_media_session"/><!-- object => MediaSessionWrapper -->
	<item type="id" name="state_player_mediacontroller_for_vol"/><!-- object => MediaController (raw). NOTE: set only when such volume controller is actually needed (e.g. not for CC) -->
	<item type="id" name="state_player_pipeline_info"/><!-- object => PipelineSessionInfo. NOTE: see also OutputEndDeviceMetaInfo which may override end device name -->
	<item type="id" name="state_player_long_seek"/><!-- boolean -->

	<item type="id" name="state_player_absvol"/><!-- int, also a msg -->

	<item type="id" name="state_player_milk_preset"/><!-- MilkPreset obj -->
	<item type="id" name="state_player_milk_mode_big_widgets"/><!-- int -->
	<item type="id" name="state_player_milk_widgets"/><!-- int -->
	<item type="id" name="state_player_milk_fd_and_serial"/><!-- long -->
	<item type="id" name="state_player_milk_sort"/><!-- int => RestMilkPreset.SORT_* -->
	<item type="id" name="state_player_milk_advance"/><!-- int => MilkAPI.ADVANCE_* -->
	
	<!-- PS inbounds commands -->
	<item type="id" name="cmd_player_play_uri"/><!-- arg1 => STATE_TRUE=>pause, STATE_FALSE/default=>play, arg2 => optional int PrefsConsts.PLAYLIST_ACTION_*, obj => Uri or Intent with the uri -->
	<item type="id" name="cmd_player_play_pos"/><!-- arg1 => pos in current list to play -->
	<item type="id" name="cmd_player_pause_playing"/><!-- arg1 => STATE_TRUE - no fade, arg2 => PsPauseFlags. Public -->
	<item type="id" name="cmd_player_resume_playing"/><!-- arg1 => STATE_TRUE - resume even if playing -->
	<item type="id" name="cmd_player_toggle_playing"/><!-- arg2 => PsPauseFlags -->
	<item type="id" name="cmd_player_play_next_track"/><!-- arg1 => flags, arg2 => trackFlags -->
	<item type="id" name="cmd_player_play_prev_track"/><!-- arg1 => boolean forceMove, arg2 => flags -->
	<item type="id" name="cmd_player_on_queue_updated"/><!-- obj = Boolean.TRUE if something is just enqueued -->
	<item type="id" name="cmd_player_reload_pipeline"/><!-- arg1 => boolean allowResume (PA), arg2 => int delay (Peq), obj = optional PipelineReloadCondition/OutputDeviceMapping -->
	<item type="id" name="cmd_player_seek"/>
	<item type="id" name="cmd_player_seek_step"/><!-- arg1 => STATE_TRUE => forward, STATE_FALSE => rewind; arg2 => step multiplier (if < 50, base=5000ms), seek jump ms, or 0 for 5000ms -->
	<item type="id" name="cmd_player_seek_jump"/><!-- arg1 => STATE_TRUE => forward, STATE_FALSE => rewind; arg2 => step ms -->
	<item type="id" name="cmd_player_begin_seek_jumps"/><!-- arg1 =>  STATE_TRUE => forward, STATE_FALSE => rewind, arg2 => optional jump duration mult (base=5000ms) -->
	<item type="id" name="cmd_player_end_seek_jumps"/><!-- -->
	<item type="id" name="cmd_player_set_rg"/>
	<item type="id" name="cmd_player_set_rg_levels"/>
	<item type="id" name="cmd_player_set_vol_levels"/><!-- Currently, no dvc headroom gain. arg1 => vol type, arg2 => float vol -->
	<item type="id" name="cmd_player_apply_pipeline_prefs"/>
	<item type="id" name="cmd_player_apply_resampler_prefs"/>
	<item type="id" name="cmd_player_set_repeat_mode"/><!-- arg1 => @integer/REPEAT_* -->
	<item type="id" name="cmd_player_set_shuffle_mode"/><!-- arg1 => @integer/SHUFFLE_* -->
	<item type="id" name="cmd_player_stop_playing"/>
	<item type="id" name="cmd_player_play_last_category"/>
	<item type="id" name="cmd_player_play_next_category"/>
	<item type="id" name="cmd_player_play_prev_category"/>
	<item type="id" name="cmd_player_play_first_category"/>
	<item type="id" name="cmd_player_reload_track"/>
	<item type="id" name="cmd_player_recreate_notification"/><!-- arg1 => boolean, true => also recreate helper -->
	<item type="id" name="cmd_player_set_master_volume"/><!-- arg1 => float volume, arg2 => flags. NOTE: this also duplicated on bus_dsp_cmd via dsp_master_volume -->
	<item type="id" name="cmd_player_adjust_master_volume"/><!-- arg1 =>0 down => 1 up, arg2 => DirectVolumeController.FLAG_* -->
	<item type="id" name="cmd_player_force_volume_panel"/>
	<item type="id" name="cmd_player_switch_track_meta"/><!-- NOTE: handled in PlayerState -->
	<item type="id" name="cmd_player_set_sleep_timer"/><!-- arg1 => seconds, arg2 => playToEnd boolean -->
	<item type="id" name="cmd_player_save_state"/>
	<item type="id" name="cmd_player_load_milk_uri"/>
	<item type="id" name="cmd_player_load_milk_preset_id"/>
	<item type="id" name="cmd_player_load_next_milk_preset"/>
	<item type="id" name="cmd_player_load_prev_milk_preset"/>
	<item type="id" name="cmd_player_set_milk_advance"/><!-- arg1 => MilkAPI.ADVANCE_* --> 
	<item type="id" name="cmd_player_set_milk_sort"/><!-- arg1 => RestMilkPreset.SORT_* -->
	<item type="id" name="cmd_player_milk_widget_state_change"/><!-- bus_player_cmd, arg1 => 0 - small widget, 1 - big widget. arg2 => 0 - stopped, 1 - started -->
	<item type="id" name="cmd_player_reregister_media_session"/><!-- Also resends external API AA to media session and widgets -->
	<item type="id" name="cmd_player_resend_external_track"/>
	<item type="id" name="cmd_player_no_search_results"/><!-- Inform player on no results for cmd_data_search_and_play, obj = incoming obj -->
	<item type="id" name="cmd_player_output_meta_changed"/><!-- Inform player on output_meta_change. arg1 => routed device_id, obj => OutputEndDeviceMetaInfo|null. Reposted to msg_player_output_meta_changed -->
	<item type="id" name="cmd_player_remove_notif"/><!-- Ask player to force remove notification and may be stop (depending on keep_service pref). arg1 => true to deactivate mediasession -->
	<item type="id" name="cmd_player_dont_resume_after_call"/>
	<item type="id" name="cmd_player_start_command"/>
	<item type="id" name="cmd_player_reset_long_volume_keys"/>
	<item type="id" name="cmd_player_use_wakelock"/><!-- arg => boolean -->
	<item type="id" name="cmd_player_enable_headset_controls"/><!-- arg => boolean -->
	<item type="id" name="cmd_player_refresh_headset_controls"/>
	<item type="id" name="cmd_player_apply_long_volume_controls"/>
	<item type="id" name="cmd_player_resolve_output_info"/><!-- arg1 => deviceId. Sent by native to force output info re-resolve -->

	
	<!-- NOTE: used for cmd_set_repeat_mode -->
	<!-- Sync with PowerampAPI.RepeatMode -->
	<integer name="REPEAT_NONE">0</integer>
	<integer name="REPEAT_ON">1</integer>
	<integer name="REPEAT_ADVANCE">2</integer>
	<integer name="REPEAT_SONG">3</integer>
	<integer name="SINGLE_SONG">4</integer>
	
	<!-- Sync with PowerampAPI.ShuffleMode -->
	<integer name="SHUFFLE_NONE">0</integer>
	<integer name="SHUFFLE_ALL">1</integer>
	<integer name="SHUFFLE_SONGS">2</integer>
	<integer name="SHUFFLE_CATS">3</integer>
	<integer name="SHUFFLE_SONGS_AND_CATS">4</integer>
		
	<!-- Sync with PowerampAPI.VisMode -->
	<integer name="VIS_NONE">0</integer>
	<integer name="VIS_W_UI">1</integer>
	<integer name="VIS_FULL_SCREEN">2</integer>
		
	<item type="id" name="msg_gui_vis_prefs_updated"/>
	<item type="id" name="cmd_data_set_milk_preset_rating"/><!-- arg1 => rating, obj => Long id -->
	<item type="id" name="cmd_set_playlist_select_sort"/>
	<item type="id" name="state_playlist_select_sort"/><!-- int -->
	<item type="id" name="cmd_set_playlist_insert_pos"/><!-- arg1 -> value, arg2 -> true - don't show toast -->
	<item type="id" name="state_playlist_insert_pos"/><!-- int -->
	<item type="id" name="cmd_set_queue_insert_pos"/>
	<item type="id" name="state_queue_insert_pos"/><!-- int -->
	<item type="id" name="cmd_set_play_next_insert_pos"/>
	<item type="id" name="state_play_next_insert_pos"/><!-- int -->

	<!-- bus_gui messages -->
	<item type="id" name="msg_gui_intermediate_seek_start"/>
	<item type="id" name="msg_gui_intermediate_seek"/><!-- arg1 = seek ms -->
	<item type="id" name="msg_gui_intermediate_seek_end"/>
	
	<item type="id" name="msg_gui_vis_panel_loaded"/><!-- obj => VisPanelFrame or null on unload -->
	
	<!-- bus_dsp* messages: bus_dspi, bus_dsp_reverb,  -->

	<item type="id" name="msg_dsp_started"/><!-- obj => DSPState -->
	<item type="id" name="msg_dsp_stopped"/><!-- obj => DSPState -->
	
	<!-- Send on eq reset, initial eq loading, eq preset setting/unsetting (not on values changing) -->
	<item type="id" name="msg_dsp_eq_changed"/><!-- arg1 => boolean - number or order of parametric bands changed, arg2 => boolean - preset changed, obj => DSPState -->
	
	<item type="id" name="msg_dsp_other_changed"/><!-- Send on other reset, obj => DSPState -->
	<item type="id" name="msg_dsp_reverb_changed"/><!-- Send on reverb reset, obj => DSPState -->
	<item type="id" name="msg_dsp_param"/><!-- arg1=> param id (dsp_*), arg2 => float, obj => DSPState -->
	<item type="id" name="msg_dsp_boolean_param"/><!-- arg1=> param id (dsp_*), arg2 => boolean, obj => DSPState -->
	
	<item type="id" name="msg_dsp_eq_band_gain"/><!-- arg1 => band index, arg2 => float  -->
	<item type="id" name="msg_dsp_eq_band_freq"/><!-- arg1 => band index, arg2 => float. Also an object state for DSPParamDef -->
	<item type="id" name="msg_dsp_eq_band_q"/><!-- arg1 => band index, arg2 => float. Also an object state for DSPParamDef -->
	<item type="id" name="msg_dsp_eq_band_color"/><!-- arg1 => band index, arg2 => value -->
	<item type="id" name="msg_dsp_eq_band_locked"/><!-- arg1 => band index, arg2 => value -->
	<item type="id" name="msg_dsp_eq_band_type"/><!-- arg1 => band index, arg2 => value -->
	<item type="id" name="msg_dsp_eq_band_ch"/><!-- arg1 => band index, arg2 => value -->	
	
	<item type="id" name="msg_dsp_tempo_state_changed"/><!-- Send on tempo state changes (e.g. enabled/disabled, plus/minus enabled/disabled)-->
	
	<item type="id" name="msg_dsp_meta_changed"/>
	
	<item type="id" name="cmd_dsp_set_param"/><!-- arg1 => param id (dsp_*), arg2 => float -->
	
	<item type="id" name="cmd_dsp_set_eq_gain"/><!-- arg1 => band ix, arg2 => float -->
	<item type="id" name="cmd_dsp_set_eq_freq"/><!-- arg1 => band ix, arg2 => float -->
	<item type="id" name="cmd_dsp_set_eq_q"/><!-- arg1 => band ix, arg2 => float -->
	<item type="id" name="cmd_dsp_set_eq_color"/><!-- arg1 => band ix, arg2 => int -->
	<item type="id" name="cmd_dsp_set_eq_locked"/><!-- arg1 => band ix, arg2 => boolean -->
	<item type="id" name="cmd_dsp_set_eq_type"/><!-- arg1 => band ix, arg2 => int -->
	<item type="id" name="cmd_dsp_set_eq_ch"/><!-- arg1 => band ix, arg2 => int -->
	<item type="id" name="cmd_dsp_reorder_eq_bands"/><!-- obj => poses[] -->
	<item type="id" name="cmd_dsp_add_eq_band"/>
	<item type="id" name="cmd_dsp_delete_eq_bands"/><!-- obj => serials[] -->
	<item type="id" name="cmd_dsp_lock_unlock_eq_bands"/><!-- arg1 => boolean, obj => serials[] -->

	<item type="id" name="cmd_dsp_reset_eq"/>
	<item type="id" name="cmd_dsp_reset_reverb"/>
	<item type="id" name="cmd_dsp_reset_other"/><!-- Resets balance, sfx, tempo, mono. arg1 => optional additional argument to reset just one parameter/plugin -->
	<item type="id" name="cmd_dsp_set_eq_preset"/><!-- arg2 -> boolean, assign to the current device, obj => PresetData -->
	<item type="id" name="cmd_dsp_set_reverb_preset"/><!-- obj => PresetData -->
	<item type="id" name="cmd_dsp_volume_may_be_changed"/><!-- arg1 => boolean isTransient -->
	<item type="id" name="cmd_dsp_switch_dsp_meta"/><!-- NOTE: handled in PlayerState -->
	<item type="id" name="cmd_dsp_open_platform_fx"/>
	<item type="id" name="cmd_dsp_tempo_plus_minus"/><!-- arg1 >= 0 - plus, arg1 < 0 - minus -->

	<item type="id" name="cmd_dsp_eq_preset_restore"/>
	<!-- Restores ALL presets -->
	<item type="id" name="cmd_dsp_restore_eq_presets"/>

	
	<!-- DSP bus params and states. Short for state_* as dsp_* prefix is enough --> 
	<item type="id" name="dsp_started"/><!-- boolean -->
	<item type="id" name="dsp_preamp"/><!-- float -->
	<item type="id" name="dsp_preamp_db"/><!-- float -->
	<item type="id" name="dsp_bass_gain"/><!-- float -->
	<item type="id" name="dsp_treble_gain"/><!-- float -->
	<item type="id" name="dsp_eq_enabled"/><!-- boolean -->
	<item type="id" name="dsp_tone_enabled"/><!-- boolean -->
	<item type="id" name="dsp_limiter_enabled"/><!-- boolean -->
	<item type="id" name="dsp_tempo_enabled"/><!-- boolean -->
	<item type="id" name="dsp_tempo_plus_enabled"/><!-- boolean -->
	<item type="id" name="dsp_tempo_minus_enabled"/><!-- boolean -->
	<item type="id" name="dsp_mono_enabled"/><!-- boolean -->
	<item type="id" name="dsp_reverb_enabled"/><!-- boolean -->
	<item type="id" name="dsp_balance_enabled"/><!-- boolean, only sent when balance changes from/to 0.5f -->
	<item type="id" name="dsp_stereo_fx_enabled"/><!-- boolean, only sent when stereoFX changes from/to 0f -->
	<item type="id" name="dsp_platform_fx_enabled"/><!-- boolean -->
	<item type="id" name="dsp_has_platform_fx"/><!-- boolean -->
	
	<!--  Returns "live" bands shallow copy. Containing array is created for each getObjectState call, band instances are the actual DSPI instances. Tone not included -->
	<item type="id" name="dsp_eq_live_bands_snapshot"/><!-- obj => Band[] -->
	<item type="id" name="dsp_tone_live_bands_snapshot"/><!-- obj => Band[] -->
	<item type="id" name="dsp_eq_parametric"/><!-- boolean -->

	<item type="id" name="dsp_balance"/><!-- float, boolean (true==enabled) -->
	<item type="id" name="dsp_stereo_fx"/><!-- float, boolean (true==enabled) -->
	<item type="id" name="dsp_tempo"/><!-- float -->
	<item type="id" name="dsp_master_volume"/><!-- float -->
	
	<item type="id" name="dsp_eq_preset_name"/><!-- String -->
	<item type="id" name="dsp_eq_preset_icon"/><!-- int -->
	<item type="id" name="dsp_eq_preset_device"/><!-- int -->
	<item type="id" name="dsp_eq_preset_device_address"/><!-- String -->
	<item type="id" name="dsp_eq_preset_id"/><!-- long -->
	<item type="id" name="dsp_eq_preset_data"/><!-- Object -->
	<item type="id" name="dsp_reverb_preset_name"/><!-- String -->
	<item type="id" name="dsp_reverb_preset_id"/><!-- long -->
	<item type="id" name="dsp_reverb_preset_data"/><!-- String -->
	
	<item type="id" name="dsp_reverb_param0"/>
	<item type="id" name="dsp_reverb_param1"/> 
	<item type="id" name="dsp_reverb_param2"/>
	<item type="id" name="dsp_reverb_param3"/>
	<item type="id" name="dsp_reverb_param4"/>
	<item type="id" name="dsp_reverb_param5"/>
	<item type="id" name="dsp_reverb_param6"/>
	<item type="id" name="dsp_reverb_param7"/>
	<item type="id" name="dsp_reverb_param8"/>
	<item type="id" name="dsp_reverb_param9"/>
	<item type="id" name="dsp_reverb_param10"/>
	
	
	<item type="id" name="dsp_resampler_type"/><!-- int -->
	<item type="id" name="dsp_resampler_cuttoff"/><!-- int -->
	<item type="id" name="dsp_resampler_dither"/><!-- int. Just current dither setting, actual dither will happen only if output bits are less than pipeline -->
	<item type="id" name="dsp_status_string"/><!-- string -->
	<item type="id" name="dsp_status_string_short"/><!-- string -->
	<item type="id" name="dsp_custom_volume_levels"/><!-- int -->
	<item type="id" name="dsp_output_info"/><!-- string, same as state_player_output_info -->
	<!-- string. Switchable meta string: can be e.g. dsp info, output info -->
	<item type="id" name="dsp_meta"/><!-- NOTE: updated on: msg_pipeline_started -->
	<item type="id" name="dsp_autosave_enabled"/><!-- boolean -->
	<!-- boolean -->
	<item type="id" name="dsp_eq_preset_locked"/>
	<!-- int -->
	<item type="id" name="dsp_eq_preset_type"/>
	<!-- boolean -->
	<item type="id" name="dsp_eq_cascade"/>


	<item type="id" name="bus_export_import"/>
	<item type="id" name="msg_export_stats"/><!-- obj => string -->


	<!-- This shares current preset -->
	<item type="id" name="cmd_data_eq_preset_share"/>
	<item type="id" name="cmd_data_eq_preset_rename"/>
	<item type="id" name="cmd_data_eq_preset_export"/>
	<item type="id" name="cmd_data_eq_preset_import"/>
	<item type="id" name="cmd_data_eq_preset_for_device"/><!-- arg1 -> routed device, obj -> device name. If 0/null, we'll query for that -->
	<item type="id" name="cmd_data_eq_preset_toast_link"/>
</resources>